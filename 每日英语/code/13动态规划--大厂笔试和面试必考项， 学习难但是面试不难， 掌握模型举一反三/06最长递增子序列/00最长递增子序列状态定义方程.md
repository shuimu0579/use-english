# 第一次遇到，确实难想到解法，记住！记住！与其说是一种题解，不如说是一种算法。

## dp 的解法

能否用 dp 解决呢？记录某个阶段决策完之后的最大递增子序列长度？

**状态定义**：dp[i]记录**以 nums[i]为结尾**的序列的最大长度。

**状态转移方程**：
那在这样一个递增子序列中（以 nums[i]结尾），
上一个数字为：nums[j](
0 <=j < i && nums[j] < nums[i])中的任意一个。
所以 dp[i] = max(dp[j]) + 1; 其中：0 <= j < i && nums[j]< nums[i]

## 回溯的解法

构建多阶段决策模型。每一阶段决策一个数字，是否放入递增子序列中。

1、如果当前的数字小于等于已经放入递增子序列中的最后一个数字，那么这个数字只能选择不放入递增子序列。
2、如果当前数字大于已经放入递增子序列中的最后一个数字，可以选择将其放入递增子序列，也可以选择不放入递增子序列。

所有决策阶段都做完之后，就找到了一个递增子序列。利用回溯算法穷举所有的递增子序列，比较出最长的那个。
